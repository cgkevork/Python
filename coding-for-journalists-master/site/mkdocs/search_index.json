{
    "docs": [
        {
            "location": "/", 
            "text": "Coding for Journalists\n\n\nThis class is an evolving introduction to coding and the Python programming language for journalists. In addition to a tour of the fundamentals, it spans nine basic projects to get you started.\n\n\nThe \nfirst version\n of this course happened at the \n2015 IRE Conference in Philadelphia\n; the repository and associated tasks have been updated since.\n\n\nA few things to note before we get rolling:\n\n\n\n\nThis guide and all documentation live at \ncoding-for-journalists.rtfd.org\n\n\nThe GitHub repository that includes all code is available from \ngithub.com/ireapps/coding-for-journalists\n\n\nA good place to raise issues with the code or ask specific questions about the code is \nalso on GitHub\n\n\nEmail\n IRE Training Director Alex Richards, the primary author of this course, or \ncontact him on Twitter\n\n\n\n\nWe have set aside time at the end of the workshop to work through the process of getting your home or work laptop set up with Python and a development environment. If you're looking for \na guide\n, we've put one together that covers most of what you'll need for OS X and Windows.\n\n\nEach task we'll tackle and set of lessons has finished and working versions of the code in the \"completed\" folder; they typically have \"_done\" appended to the end of the filename. If there isn't enough time to hit each one during our time together, there's enough commenting in place that you should be able to work through them on your own (and feel free to bug \nAlex\n).\n\n\nThis is designed for people who have some grounding in data journalism already and experience with spreadsheets and database managers. It's helpful if you understand Excel functions, for example, and some basic SQL. Other important skills include navigation of the computer's command line; we'll bemoving between folders, running scripts and issuing commands to a Python interpreter.\n\n\nWhat the next few days have in store\n\n\nIntroduction\n\n\nA whirlwind tour of Python's data types, variables, basic functionality and loops. We'll write a bunch of them on our own, discuss them, and then run a script in the iPython interactive interpreter to load a variety of variables and then start messing with them.\n\n\nWe'll also talk about how to format strings \u2014 which we'll be doing a ton \u2014 and how Python deals with whitespace.\n\n\nScraping data from the web\n\n\nFetching data from the web was one of programming's original beachheads in the journalism world. We're going to grab a data table from a website and turn it into a delimited text file to use in a spreadsheet or database manager.\n\n\nThis is a task one could arguably accomplish using Excel's \"import from web\" feature, so we're going to take it one step further: we'll alter our script to drill into additional detail pages and automatically extract more columns of data for our text file.\n\n\nWe'll also drill into the finer points of using the BeautifulSoup library to parse HTML, reading and writing CSV files, and targeting data with regular expressions.\n\n\nParsing records that fall across multiple lines\n\n\nData don't always arrive in a nice, neat table. We have hundreds of addresses to parse into a format that will work in Excel or a database manager, and Python is going to help us make it happen. We'll write a script that dices it all and puts everything in its proper place -- one line for one location.\n\n\nMaking a reusable function\n\n\nIn this quick project, we'll modify the address parsing script we wrote in the previous exercise, turning it into a reusable function that we can apply to future address lists that arrive in the same problematic format.\n\n\nGeocoding with Python\n\n\nGeocoding is one of those perennial data journalism problems that's gotten easier in some ways over the years, yet harder in others. While having a street address is great, having a latitude and longitude is better. We'll take the poorly formatted addresses we coaxed into a flat file and march them one at a time through an online geocoding service using a handy Python library called \ngeopy\n.\n\n\nWorking with APIs and databases\n\n\nApplication Programming Interfaces have become a common spigot for data on the web. We'll tap into one maintained by the city of Chicago that deals with crime and send it to a table in a SQLite database. From there, we'll write some scripted queries to isolate interesting information.\n\n\nWe'll also dig in on how Python interacts with databases and how it deals with dates and times.\n\n\nUnlocking data stuck in a database\n\n\nA database is a great reporting tool, having your data and analysis locked up there don't help your audience much. We're going to work with the same crime data we processed earlier and turn it into a web-friendly format (GeoJSON) for automatic display on a very basic Leaflet.js map. \n\n\nThe wonderful world of data cleaning\n\n\nOnce you figure out what the problems are with a data set, you can outsource the tedious cleaning process to Python. We'll focus on a few different types of cleaning you're likely to encounter in your reporting life, including Excel files where data is scattered around different rows and columns, CSV files with obvious errors that \n\n\nOther kinds of scrapes\n\n\nWe're not always after web tables; sometimes we're trying to collect a bunch of files scattered around a website or need to POST some data in order to get a response from a dynamic page, like a government site that uses ASP.NET. \n\n\nThe deal with text encoding and debugging your scripts\n\n\nWhat's ASCII? Why the hell am I getting \nUnicodeEncodeError\n? We'll deal sporadically with text encoding in some of these other lessons, but we'll focus on why it's important and what you can do to stay on top of it. In addition, we'll look through common errors you'll run into, what they mean and how to fix them.", 
            "title": "Main"
        }, 
        {
            "location": "/#coding-for-journalists", 
            "text": "This class is an evolving introduction to coding and the Python programming language for journalists. In addition to a tour of the fundamentals, it spans nine basic projects to get you started.  The  first version  of this course happened at the  2015 IRE Conference in Philadelphia ; the repository and associated tasks have been updated since.  A few things to note before we get rolling:   This guide and all documentation live at  coding-for-journalists.rtfd.org  The GitHub repository that includes all code is available from  github.com/ireapps/coding-for-journalists  A good place to raise issues with the code or ask specific questions about the code is  also on GitHub  Email  IRE Training Director Alex Richards, the primary author of this course, or  contact him on Twitter   We have set aside time at the end of the workshop to work through the process of getting your home or work laptop set up with Python and a development environment. If you're looking for  a guide , we've put one together that covers most of what you'll need for OS X and Windows.  Each task we'll tackle and set of lessons has finished and working versions of the code in the \"completed\" folder; they typically have \"_done\" appended to the end of the filename. If there isn't enough time to hit each one during our time together, there's enough commenting in place that you should be able to work through them on your own (and feel free to bug  Alex ).  This is designed for people who have some grounding in data journalism already and experience with spreadsheets and database managers. It's helpful if you understand Excel functions, for example, and some basic SQL. Other important skills include navigation of the computer's command line; we'll bemoving between folders, running scripts and issuing commands to a Python interpreter.", 
            "title": "Coding for Journalists"
        }, 
        {
            "location": "/#what-the-next-few-days-have-in-store", 
            "text": "Introduction  A whirlwind tour of Python's data types, variables, basic functionality and loops. We'll write a bunch of them on our own, discuss them, and then run a script in the iPython interactive interpreter to load a variety of variables and then start messing with them.  We'll also talk about how to format strings \u2014 which we'll be doing a ton \u2014 and how Python deals with whitespace.  Scraping data from the web  Fetching data from the web was one of programming's original beachheads in the journalism world. We're going to grab a data table from a website and turn it into a delimited text file to use in a spreadsheet or database manager.  This is a task one could arguably accomplish using Excel's \"import from web\" feature, so we're going to take it one step further: we'll alter our script to drill into additional detail pages and automatically extract more columns of data for our text file.  We'll also drill into the finer points of using the BeautifulSoup library to parse HTML, reading and writing CSV files, and targeting data with regular expressions.  Parsing records that fall across multiple lines  Data don't always arrive in a nice, neat table. We have hundreds of addresses to parse into a format that will work in Excel or a database manager, and Python is going to help us make it happen. We'll write a script that dices it all and puts everything in its proper place -- one line for one location.  Making a reusable function  In this quick project, we'll modify the address parsing script we wrote in the previous exercise, turning it into a reusable function that we can apply to future address lists that arrive in the same problematic format.  Geocoding with Python  Geocoding is one of those perennial data journalism problems that's gotten easier in some ways over the years, yet harder in others. While having a street address is great, having a latitude and longitude is better. We'll take the poorly formatted addresses we coaxed into a flat file and march them one at a time through an online geocoding service using a handy Python library called  geopy .  Working with APIs and databases  Application Programming Interfaces have become a common spigot for data on the web. We'll tap into one maintained by the city of Chicago that deals with crime and send it to a table in a SQLite database. From there, we'll write some scripted queries to isolate interesting information.  We'll also dig in on how Python interacts with databases and how it deals with dates and times.  Unlocking data stuck in a database  A database is a great reporting tool, having your data and analysis locked up there don't help your audience much. We're going to work with the same crime data we processed earlier and turn it into a web-friendly format (GeoJSON) for automatic display on a very basic Leaflet.js map.   The wonderful world of data cleaning  Once you figure out what the problems are with a data set, you can outsource the tedious cleaning process to Python. We'll focus on a few different types of cleaning you're likely to encounter in your reporting life, including Excel files where data is scattered around different rows and columns, CSV files with obvious errors that   Other kinds of scrapes  We're not always after web tables; sometimes we're trying to collect a bunch of files scattered around a website or need to POST some data in order to get a response from a dynamic page, like a government site that uses ASP.NET.   The deal with text encoding and debugging your scripts  What's ASCII? Why the hell am I getting  UnicodeEncodeError ? We'll deal sporadically with text encoding in some of these other lessons, but we'll focus on why it's important and what you can do to stay on top of it. In addition, we'll look through common errors you'll run into, what they mean and how to fix them.", 
            "title": "What the next few days have in store"
        }, 
        {
            "location": "/install/", 
            "text": "The ingredients for an install\n\n\nGetting to the point where you can do this at work or home can be half the battle. The good news is that it can pretty much all be had for free. Let's talk for a second about what this will require:\n\n\n\n\nA text editor\n\n\nPython\n\n\nAccess to a command line interface\n\n\npip\n\n\nvirtualenv\n\n\nvirtualenvwrapper\n\n\nA connection to the internet\n\n\n\n\nHere's what the various parts do, as well as why you need them:\n\n\nThe text editor\n allows you to write scripts for the Python interpreter in a plain text format. Something along the lines of a full word processor (think Microsoft Word or Apple's Pages) won't cut it; those are designed for presentation and resulting files will be cluttered with a bunch of elements that control text styling. Having one at your disposal is a must for writing code and great for examining data.\n\n\nPython\n is the engine of the entire affair; it's a code interpreter that's going to look at the commands you write and then faithfully execute them. At the moment this code and guide is designed around version 2.7.\n\n\nAccess to a command line interface\n in the form of the OS X terminal or Windows command prompt. It will be used to run Python scripts and access the Python interpreter.\n\n\npip\n is an external Python library that helps you manage the download and installation of packages that don't come with standard Python. There's a lot there already, sure, but people have written new modules to assist with tasks like web scraping and dealing with PDF files. It makes adding new functionality as easy as typing \npip install \nsome new package\n. \npip\n will fetch it from the internet and install it for you -- and do the same for any other packages required to make it all work correctly.\n\n\nvirtualenv\n is an external Python library that allows you to create virtual sandboxes where your scripts can live and have their own packages, completely compartmentalized from one another. It solves a problem in development where you may have conflicting package needs among different pieces of code. It also insulates you from mucking around with the core Python and \npip\n you'll be installing. When a new virtual environment is created, it springs up with its own copy of Python and \npip\n. The packages in the environment can be modified, removed and reset at will, but it will never screw with the underlying Python and \npip\n on the system, even if the environment is deleted.\n\n\nvirtualenvwrapper\n is another external Python library that just makes it easier to deal with the various virtual environments; it keeps them organized in one place, and you can easily jump in and out of environments with a few brief commands. It's important to note that the Windows command prompt has its own version (\nvirtualenvwrapper-win\n).\n\n\nA connection to the internet\n is necessary because \npip\n will be fetching packages from the web.\n\n\nOn Windows\n\n\n\n\nNote\n\n\nThis guide is for Windows 8.1. For other versions of Windows, this process should be similar.\n\n\n\n\n1. \nDownload Python 2.7\n\n\nYou'll want to download the \nmost current release of Python 2 for Windows\n; you'll likely have the best luck with the \nWindows x86 MSI installer\n.\n\n\n\n\n2. \nInstall Python 2.7\n\n\nAfter opening the installer, there are two things you'll want to include during the installation process that should make your life much easier.\n\n\nFirst, the installer will give you the option of having \npip\n ride along with the rest of the Python installation. By default, this should already be selected for you.\n\n\nSecond, the installer will give you the option to add python.exe to your PATH. All that means is that typing \npython\n at the command prompt will get you to the interpreter or give you the ability to execute a Python script, regardless of where you've navigated on your system. By default, this will \nnot\n be selected; you'll have to change it on your own.\n\n\nMake sure both of these options are selected before completing the install.\n\n\n\n\n3. \nVerify installation of Python and pip\n\n\nOpen the Windows command prompt. If you're unable to locate it in the \"Start\" menu, search for an application called \ncmd\n.\n\n\nTo check that Python was installed successfully, issue the following command:\n\n\npython --version\n\n\n\n\nIf everything went as planned, this should spit out the version number of Python you just installed. \n\n\n\n\nCaution\n\n\nIf you get an error message that says Python isn't recognized as a legitimate command, something's gone awry. Python may not have been added to your command prompt PATH, which you can resolve by following step 3 in \nthis guide\n. If the main Python directory, its Scripts folder and site-packages are all in the PATH, you'll need to attempt to reinstall.\n\n\n\n\nOnce we've verified all is well with Python, let's turn our attention to \npip\n:\n\n\npip list\n\n\n\n\nIf \npip\n was installed correctly along with Python, you should get a quick recap of nonstandard packages it can find. The output probably looks something like:\n\n\npip (7.0.1)\nsetuptools (16.0)\n\n\n\n\nIt may also have a message griping about an outdated version of \npip\n, but let's not worry about that right now.\n\n\n\n\nCaution\n\n\nIf the command prompt threw some kind of error at you, \npip\n may not be installed and there are a couple of things you can try. You can reinstall Python from the MSI file and make sure the option to install \npip\n is selected. It can also be installed manually by following \nthe instructions here\n.\n\n\n\n\n\n\n4. \nInstall virtualenv\n\n\nWith \npip\n, adding the \nvirtualenv\n package is as easy as typing:\n\n\npip install virtualenv\n\n\n\n\nIt should appear among pip and setuptools when you type \npip list\n and you should be able to verify the version with:\n\n\nvirtualenv --version\n\n\n\n\n\n\n5. \nInstall virtualenvwrapper-win\n\n\nYou may start to be seeing a pattern here with installation using \npip\n:\n\n\npip install virtualenvwrapper-win\n\n\n\n\n\n\nCaution\n\n\nIf you prefer to use a more robust command line interface like Windows PowerShell, note that the package \nvirtualenvwrapper-win\n won't work; try something like \nvirtualenvwrapper-powershell\n instead.\n\n\n\n\nThis wrapper just adds commands for easier interaction with \nvirtualenv\n. For example: Instead of having to navigate to an environment's \"Scripts\" folder and \nactivate\n it, typing \nworkon \nvirtual environment\n wherever you're navigated in the system achieves the same effect.\n\n\n\n\nCaution\n\n\nTcl\n and \ntk\n come with Python 2.7 and don't appear to automatically work inside of Windows virtualenvs; this will derail things like \n%paste\n in iPython. You'll need to navigate to the virtualenv's folder and modify the \nactivate.bat\n script by adding the following lines (with the paths to your installation of Python \u2014 defaults below): \n\n\n\n\nset \nTCL_LIBRARY=C:\\Python27\\tcl\\tcl8.5\n\nset \nTK_LIBRARY=C:\\Python27\\tcl\\tk8.5\n\n\n\n\n\n\nOther ways into Python on Windows\n\n\nIn recent years IRE has been teaching Python in PC labs, and the easiest way to get everyone set up quickly has been to use the \nAnaconda distribution of Python\n, which comes with many popular nonstandard libraries already installed alongside the core program.\n\n\nThis remains an option available to you; it comes with \npip\n and has its own method of segregating projects into virtual environments.\n\n\n\n\nOn OS X\n\n\nPython comes pre-installed on OS X, which actually makes the process of getting set up properly more difficult.\n\n\nYes, more difficult.\n\n\nThe version accompanying OS X has been tinkered with by Apple, and it's responsible for other functionality on your computer. It's also likely out of date.\n\n\nThe accepted way to get around this problem is to install an OS X program called \nHomebrew\n, which is essentially a package manager for your system \u2014 similar to what pip does for Python. It will allow you to download an independent and updateable version of Python that you can use going forward. A side benefit is that pip comes with the Python you install with Homebrew.\n\n\nNot to evangelize about Homebrew too much, but if you decide to travel down the path leading to some of the more complex data journalism techniques on the command line, you'll find other uses for Homebrew and its many packages beyond just providing a clean copy of Python.\n\n\nIt has downsides; Homebrew requires a current version of Apple's Xcode's command line tools to be installed on your computer first. A full guide is \navailable here\n to get you up and running.\n\n\n\n\nCaution\n\n\nChanges in OS X 10.11 El Capitan can make this process even trickier. Apple insituted extra system protections that have the capability of adding a few steps to the Homebrew install process. If you're running into these issues, \nread this\n for more information.\n\n\n\n\n\n\nNote\n\n\nYou can also use the built-in OS X Python if you wish. The next step in that case will be getting pip up and running.\n\n\n\n\n1. \nCheck for pip\n\n\nHomebrew's Python comes with pip in tow. If you're using the OS X system version, let's see if it's installed. Open the Terminal and type the following:\n\n\npip -V\n\n\n\n\nIf pip is installed, this will return a version number.\n\n\n\n\n2. \nIf it's not there: Get pip\n\n\nDownload \nget-pip.py\n, navigate to it and type the following:\n\n\npython get-pip.py\n\n\n\n\nFor more information on installing pip, there's a \nwalkthrough\n as a part of its online documentation.\n\n\n\n\n3. \nVerify the presence of Python and pip\n\n\nLet's see what we're working with here and check to make sure all is well:\n\n\npython -V\npip -V\n\n\n\n\n\n\n4. \nGet and install virtualenv\n\n\nWith \npip\n, adding the \nvirtualenv\n package is as easy as typing:\n\n\npip install virtualenv\n\n\n\n\nIt should appear among pip and setuptools when you type \npip list\n and you should be able to verify the version with:\n\n\nvirtualenv --version\n\n\n\n\n\n\n5. \nGet and install virtualenvwrapper\n\n\nWe can install virtualenvwrapper with \npip\n as well:\n\n\npip install virtualenvwrapper\n\n\n\n\nThis wrapper just adds commands for easier interaction with \nvirtualenv\n. For example: Instead of having to navigate to an environment's \"Scripts\" folder and \nactivate\n it, typing \nworkon \nvirtual environment\n wherever you're navigated in the system achieves the same effect.\n\n\n\n\n6. \nModify your .bash_profile so you can use virtualenvwrapper commands and give your virtualenvs a home\n\n\nThis can be accomplished by opening your .bash_profile, which is typically in your main user directory. Typing:\n\n\nopen -e ~/.bash_profile\n\n\n\n\nOpens the file in your system's default text editor \u2014 probably TextEdit.\n\n\nIf you get an error saying that the file doesn't exist, create one and then try opening it again.\n\n\ntouch ~/.bash_profile\nopen -e ~/.bash_profile\n\n\n\n\nThe following lines need to be added once it's been opened:\n\n\nexport WORKON_HOME=~/Envs\nsource /usr/local/bin/virtualenvwrapper.sh\n\n\n\n\nThe first line just sets up a directory for your virtual environments; if you don't want them in your Home directory in a folder called \"Envs,\" you can change the path accordingly.\n\n\nThe second line is a hook for \nvirtualenvwrapper\n so that its commands will work when you type them in the Terminal. \n\n\n\n\n7. \nReload your .bash_profile\n\n\nSo that these new changes take effect, type:\n\n\nsource ~/.bash_profile\n\n\n\n\nYou should see several new thing run in the Terminal after the reload as it makes a place for your environments.\n\n\n\n\nTest run\n\n\nmkvirtualenv mytest\ndeactivate\nworkon\nworkon mytest\npip list mytest\n\n\n\n\nThese lines do the following:\n\n\n\n\nCreate a new virtual environment called \"mytest\"\n\n\nExit the \"mytest\" environment\n\n\nList the virtual environments that presently exist\n\n\nMove into the \"mytest\" environment again\n\n\nList all libraries presently installed in \"mytest\"\n\n\n\n\n\n\nGetting \"Coding for Journalists\"\n\n\nA repository for all of the files is presently hosted on GitHub, which is likely how you navigated here in the first place. You can just \ncopy a zipped version\n of all the files for your use or fork it using GitHub's desktop application or git from the command line. For help with git and GitHub, there are some \nresources in \"Next Steps.\"\n\n\nOnce you have the files, you'll need to set up a virtualenv told hold the required libraries.\n\n\nmkvirtualenv cfj\n\n\n\n\nYou should automatically be placed inside the new virtualenv after creation. From there, the \nrequirements.txt\n file within the main folder lists every necessary library to make these scripts run.\n\n\npip install -r requirements.txt\n\n\n\n\n\n\nCaution\n\n\nOne requirement isn't designed for Windows, so there is a separate file \nrequirements-win.txt\n that should be used instead.\n\n\n\n\nOnce that's done, you'll have non-standard Python libraries and add-ons like \ngeopy\n, \niPython\n and \nrequests\n at your disposal.", 
            "title": "Setting up your computer"
        }, 
        {
            "location": "/install/#the-ingredients-for-an-install", 
            "text": "Getting to the point where you can do this at work or home can be half the battle. The good news is that it can pretty much all be had for free. Let's talk for a second about what this will require:   A text editor  Python  Access to a command line interface  pip  virtualenv  virtualenvwrapper  A connection to the internet   Here's what the various parts do, as well as why you need them:  The text editor  allows you to write scripts for the Python interpreter in a plain text format. Something along the lines of a full word processor (think Microsoft Word or Apple's Pages) won't cut it; those are designed for presentation and resulting files will be cluttered with a bunch of elements that control text styling. Having one at your disposal is a must for writing code and great for examining data.  Python  is the engine of the entire affair; it's a code interpreter that's going to look at the commands you write and then faithfully execute them. At the moment this code and guide is designed around version 2.7.  Access to a command line interface  in the form of the OS X terminal or Windows command prompt. It will be used to run Python scripts and access the Python interpreter.  pip  is an external Python library that helps you manage the download and installation of packages that don't come with standard Python. There's a lot there already, sure, but people have written new modules to assist with tasks like web scraping and dealing with PDF files. It makes adding new functionality as easy as typing  pip install  some new package .  pip  will fetch it from the internet and install it for you -- and do the same for any other packages required to make it all work correctly.  virtualenv  is an external Python library that allows you to create virtual sandboxes where your scripts can live and have their own packages, completely compartmentalized from one another. It solves a problem in development where you may have conflicting package needs among different pieces of code. It also insulates you from mucking around with the core Python and  pip  you'll be installing. When a new virtual environment is created, it springs up with its own copy of Python and  pip . The packages in the environment can be modified, removed and reset at will, but it will never screw with the underlying Python and  pip  on the system, even if the environment is deleted.  virtualenvwrapper  is another external Python library that just makes it easier to deal with the various virtual environments; it keeps them organized in one place, and you can easily jump in and out of environments with a few brief commands. It's important to note that the Windows command prompt has its own version ( virtualenvwrapper-win ).  A connection to the internet  is necessary because  pip  will be fetching packages from the web.", 
            "title": "The ingredients for an install"
        }, 
        {
            "location": "/install/#on-windows", 
            "text": "Note  This guide is for Windows 8.1. For other versions of Windows, this process should be similar.   1.  Download Python 2.7  You'll want to download the  most current release of Python 2 for Windows ; you'll likely have the best luck with the  Windows x86 MSI installer .   2.  Install Python 2.7  After opening the installer, there are two things you'll want to include during the installation process that should make your life much easier.  First, the installer will give you the option of having  pip  ride along with the rest of the Python installation. By default, this should already be selected for you.  Second, the installer will give you the option to add python.exe to your PATH. All that means is that typing  python  at the command prompt will get you to the interpreter or give you the ability to execute a Python script, regardless of where you've navigated on your system. By default, this will  not  be selected; you'll have to change it on your own.  Make sure both of these options are selected before completing the install.   3.  Verify installation of Python and pip  Open the Windows command prompt. If you're unable to locate it in the \"Start\" menu, search for an application called  cmd .  To check that Python was installed successfully, issue the following command:  python --version  If everything went as planned, this should spit out the version number of Python you just installed.    Caution  If you get an error message that says Python isn't recognized as a legitimate command, something's gone awry. Python may not have been added to your command prompt PATH, which you can resolve by following step 3 in  this guide . If the main Python directory, its Scripts folder and site-packages are all in the PATH, you'll need to attempt to reinstall.   Once we've verified all is well with Python, let's turn our attention to  pip :  pip list  If  pip  was installed correctly along with Python, you should get a quick recap of nonstandard packages it can find. The output probably looks something like:  pip (7.0.1)\nsetuptools (16.0)  It may also have a message griping about an outdated version of  pip , but let's not worry about that right now.   Caution  If the command prompt threw some kind of error at you,  pip  may not be installed and there are a couple of things you can try. You can reinstall Python from the MSI file and make sure the option to install  pip  is selected. It can also be installed manually by following  the instructions here .    4.  Install virtualenv  With  pip , adding the  virtualenv  package is as easy as typing:  pip install virtualenv  It should appear among pip and setuptools when you type  pip list  and you should be able to verify the version with:  virtualenv --version   5.  Install virtualenvwrapper-win  You may start to be seeing a pattern here with installation using  pip :  pip install virtualenvwrapper-win   Caution  If you prefer to use a more robust command line interface like Windows PowerShell, note that the package  virtualenvwrapper-win  won't work; try something like  virtualenvwrapper-powershell  instead.   This wrapper just adds commands for easier interaction with  virtualenv . For example: Instead of having to navigate to an environment's \"Scripts\" folder and  activate  it, typing  workon  virtual environment  wherever you're navigated in the system achieves the same effect.   Caution  Tcl  and  tk  come with Python 2.7 and don't appear to automatically work inside of Windows virtualenvs; this will derail things like  %paste  in iPython. You'll need to navigate to the virtualenv's folder and modify the  activate.bat  script by adding the following lines (with the paths to your installation of Python \u2014 defaults below):    set  TCL_LIBRARY=C:\\Python27\\tcl\\tcl8.5 \nset  TK_LIBRARY=C:\\Python27\\tcl\\tk8.5   Other ways into Python on Windows  In recent years IRE has been teaching Python in PC labs, and the easiest way to get everyone set up quickly has been to use the  Anaconda distribution of Python , which comes with many popular nonstandard libraries already installed alongside the core program.  This remains an option available to you; it comes with  pip  and has its own method of segregating projects into virtual environments.", 
            "title": "On Windows"
        }, 
        {
            "location": "/install/#on-os-x", 
            "text": "Python comes pre-installed on OS X, which actually makes the process of getting set up properly more difficult.  Yes, more difficult.  The version accompanying OS X has been tinkered with by Apple, and it's responsible for other functionality on your computer. It's also likely out of date.  The accepted way to get around this problem is to install an OS X program called  Homebrew , which is essentially a package manager for your system \u2014 similar to what pip does for Python. It will allow you to download an independent and updateable version of Python that you can use going forward. A side benefit is that pip comes with the Python you install with Homebrew.  Not to evangelize about Homebrew too much, but if you decide to travel down the path leading to some of the more complex data journalism techniques on the command line, you'll find other uses for Homebrew and its many packages beyond just providing a clean copy of Python.  It has downsides; Homebrew requires a current version of Apple's Xcode's command line tools to be installed on your computer first. A full guide is  available here  to get you up and running.   Caution  Changes in OS X 10.11 El Capitan can make this process even trickier. Apple insituted extra system protections that have the capability of adding a few steps to the Homebrew install process. If you're running into these issues,  read this  for more information.    Note  You can also use the built-in OS X Python if you wish. The next step in that case will be getting pip up and running.   1.  Check for pip  Homebrew's Python comes with pip in tow. If you're using the OS X system version, let's see if it's installed. Open the Terminal and type the following:  pip -V  If pip is installed, this will return a version number.   2.  If it's not there: Get pip  Download  get-pip.py , navigate to it and type the following:  python get-pip.py  For more information on installing pip, there's a  walkthrough  as a part of its online documentation.   3.  Verify the presence of Python and pip  Let's see what we're working with here and check to make sure all is well:  python -V\npip -V   4.  Get and install virtualenv  With  pip , adding the  virtualenv  package is as easy as typing:  pip install virtualenv  It should appear among pip and setuptools when you type  pip list  and you should be able to verify the version with:  virtualenv --version   5.  Get and install virtualenvwrapper  We can install virtualenvwrapper with  pip  as well:  pip install virtualenvwrapper  This wrapper just adds commands for easier interaction with  virtualenv . For example: Instead of having to navigate to an environment's \"Scripts\" folder and  activate  it, typing  workon  virtual environment  wherever you're navigated in the system achieves the same effect.   6.  Modify your .bash_profile so you can use virtualenvwrapper commands and give your virtualenvs a home  This can be accomplished by opening your .bash_profile, which is typically in your main user directory. Typing:  open -e ~/.bash_profile  Opens the file in your system's default text editor \u2014 probably TextEdit.  If you get an error saying that the file doesn't exist, create one and then try opening it again.  touch ~/.bash_profile\nopen -e ~/.bash_profile  The following lines need to be added once it's been opened:  export WORKON_HOME=~/Envs\nsource /usr/local/bin/virtualenvwrapper.sh  The first line just sets up a directory for your virtual environments; if you don't want them in your Home directory in a folder called \"Envs,\" you can change the path accordingly.  The second line is a hook for  virtualenvwrapper  so that its commands will work when you type them in the Terminal.    7.  Reload your .bash_profile  So that these new changes take effect, type:  source ~/.bash_profile  You should see several new thing run in the Terminal after the reload as it makes a place for your environments.", 
            "title": "On OS X"
        }, 
        {
            "location": "/install/#test-run", 
            "text": "mkvirtualenv mytest\ndeactivate\nworkon\nworkon mytest\npip list mytest  These lines do the following:   Create a new virtual environment called \"mytest\"  Exit the \"mytest\" environment  List the virtual environments that presently exist  Move into the \"mytest\" environment again  List all libraries presently installed in \"mytest\"", 
            "title": "Test run"
        }, 
        {
            "location": "/install/#getting-coding-for-journalists", 
            "text": "A repository for all of the files is presently hosted on GitHub, which is likely how you navigated here in the first place. You can just  copy a zipped version  of all the files for your use or fork it using GitHub's desktop application or git from the command line. For help with git and GitHub, there are some  resources in \"Next Steps.\"  Once you have the files, you'll need to set up a virtualenv told hold the required libraries.  mkvirtualenv cfj  You should automatically be placed inside the new virtualenv after creation. From there, the  requirements.txt  file within the main folder lists every necessary library to make these scripts run.  pip install -r requirements.txt   Caution  One requirement isn't designed for Windows, so there is a separate file  requirements-win.txt  that should be used instead.   Once that's done, you'll have non-standard Python libraries and add-ons like  geopy ,  iPython  and  requests  at your disposal.", 
            "title": "Getting \"Coding for Journalists\""
        }, 
        {
            "location": "/pt1/", 
            "text": "Introduction\n\n\nBefore we do anything, we need to understand some of the components we'll be interacting with and switching between.\n\n\n\n\n\n\nThe Python interpreter\n: we input commands, define variables and functions, write loops, etc. The interpreter parses it all for us, line by line as we write them, and takes action.\n\n\n\n\n\n\nText editor\n: this is where we essentially chain a bunch of commands together within a single document and save it as a Python script (ending in \n.py\n).\n\n\n\n\n\n\nThe command line\n: Accessed via \"Terminal\" on OS X or \"cmd.exe\" (or possibly PowerShell) on Windows. It's where we run the Python interpreter, among other programs, and issue commands that allow us to navigate our computer's folders.\n\n\n\n\n\n\nThat's pretty much it. These three pieces give you a container for code you're writing, the program to run it and a method to get it all running. We'll be doing some switching back and forth between entering code directly into the interpreter we run from the command line and the text editor.\n\n\nAs we progress, we'll be dealing with two other things.\n\n\n\n\n\n\nExternal libraries\n: Python comes with a standard library that has a ton of useful stuff. Developers have written libraries that take this functionality even further. By importing parts of these libraries into our Python script, we can do complex things, like fetch a web page, with a single line of code.\n\n\n\n\n\n\nA virtual enviroment\n: The bubble where all of our code lives.\n\n\n\n\n\n\nThis is a crash course in some of Python's major data types and and how to tame them. We'll be doing things like mashing strings together, running through items in a list and defining very simple functions.\n\n\nWe'll be using iPython's interactive interpreter, which means we have access to a few extra features (which iPython modestly calls \nmagic functions\n).\n\n\nThe files in this folder:\n\n\n\n\n\n\nvar.py\n: A Python script with some variables of different types like integers, lists and dictionaries.\n\n\n\n\n\n\nexercises.py\n: A file that gives a list of exercises in the form of comments; guidance on how to manipulate the variables in \nvar.py\n. It's also the place we can write code to save for future reference. Nearly everything we do in this task will use iPython.\n\n\n\n\n\n\nfun_with_subs.py\n: A file for practicing string substitutions, which is something we'll be doing frequently. It covers the depreciated method you'll encounter frequently and covers \nstr.format()\n.\n\n\n\n\n\n\nwhitespace.py\n: A guide to how Python decides which blocks of code to run when; it's all controlled by indentation.\n\n\n\n\n\n\nAny finished versions will appear in the \ncompleted\n folder.\n\n\nOpening iPython is as easy as typing \nipython\n into PowerShell.\n\n\nTo get everything from \nvar.py\n queued up, we can either run it from within iPython using one of the \nmagic functions\n:\n\n\n%run var.py\n\n\n\n\nOr we can use the more traditional method of importing everything defined in a script, treating it as a module:\n\n\nfrom var import *\n\n\n\n\nThis will make a little more sense as we start bringing in other Python libraries to tackle our other tasks. Either way, it's going to get us those variables defined in \nvar.py\n. We can quickly test that these variables were loaded by typing \nlucky_number\n.\n\n\nLet's say I have a longer chunk of code that I want to try out in iPython to see if it works as expected.\n\n\npresents = ['A brand new car', 'Socks']\n\nfor gift in presents:\n    if gift == 'A brand new car':\n        print gift, '\n- Oh yeah!'\n    else:\n        print gift, '\n- Meh.'\n\n\n\n\nHaving to type this line by line into the interpreter and pay attention to indentation can be a pain.\n\n\nBut I can write that block of code in a text editor instead, then select it all and copy it. Switching over to iPython, I can use the built-in paste function:\n\n\n%paste\n\n\n\n\nThis will paste the contents of my clipboard, preserving all the indentation and other white space, and execute whatever code was there. Pretty handy.\n\n\nFinally, iPython has another function that will give you a recap of commands you've typed:\n\n\n%history", 
            "title": "Introduction"
        }, 
        {
            "location": "/pt2/", 
            "text": "Scraping the web\n\n\nNow that we've familiarized ourselves with the ways Python works, we have a little bit of a foundation to build from. Nearly everything else we do today is going to be using the fundamentals from \nthe intro\n to varying degrees and in different combinations to create longer scripts.\n\n\nSo let's scrape a web page. We want to collect all the data from the main table on the U.S. Nuclear Regulatory Commission's \nlist of domestic power reactor units\n.\n\n\nPython comes with a library installed that's designed specifically for reading and writing CSV files (\ncsv\n), but we're also going to need to extend Python's functionality a bit by bringing in two other libraries.\n\n\nOne is \nrequests\n -- it handles the job of playing a web browser that can fetch a web page and send back the underlying HTML. The other is \nBeautifulSoup\n, which parses the HTML into what amounts to a series of lists that we can then search, navigate and extract data from.\n\n\nWhen we get to part two, we'll use the built-in regular expressions library \nre\n to isolate some text from the detail pages and \ntime\n to keep us from swamping a government site with too many requests at once.\n\n\nA big thank you to \nAnthony DeBarros\n for allowing us to present a modified version of his web scraping example from \npython-get-started\n.\n\n\nWe'll use the following files:\n\n\n\n\n\n\nscrape.py\n: The file we'll use to write our scraping script, following the comments.\n\n\n\n\n\n\nscrape_pt2.py\n: The file we'll use to push our scraping script further; it contains finished code for \nscrape.py\n and open spots to add code that loops through to detail pages and collects additional information.\n\n\n\n\n\n\nnrc_backup.html\n: A backup version of the main table we want to scrape in case there's a connection problem.\n\n\n\n\n\n\ntable_example.html\n: A bare bones HTML table that shows the basic tags and how they're nested, with the flourishes of a modern web page stripped away -- it's ugly.\n\n\n\n\n\n\nfun_with_bs.py\n: A primer for some of BeautifulSoup's most relevant commands for navigating HTML.\n\n\n\n\n\n\nfun_with_csv.py\n: A brief example of how Python uses its standard csv library to read and write delimited-text files.\n\n\n\n\n\n\nfun_with_regex.py\n: A file that covers some regular expresses in Python for finding and isolating text.\n\n\n\n\n\n\nFinished versions will appear in the \ncompleted\n folder.", 
            "title": "Scraping the web"
        }, 
        {
            "location": "/pt3/", 
            "text": "Parsing text across lines\n\n\nIt would be great if every piece of data you came across was in a format that lent itself to easy capture. In the same vein as the text extraction from reactor detail pages in our last example, we're going to pick apart an HTML file of licensed payday lenders (that's mostly text) and turn it into a flat CSV file where one row is one record.\n\n\nIn this file, addresses can span three, four or five lines. Sometimes it's on four lines because a lender does business in Illinois under another name; in others, it's because the lender operates out of a suite, room or building stored on a line separate from the street address. This means that our script needs to behave four different ways depending on how many lines it encounters for each address, and we'll switch among those behaviors with \nif/elif\n syntax.\n\n\nWe'll again use \nBeautifulSoup\n, but primarily to break out the portion of the file we want to capture for the resulting CSV.\n\n\nThis exercise has the following files:\n\n\n\n\n\n\npayday.py\n: The file we'll use to write our address parser, following the comments.\n\n\n\n\n\n\npayday_lenders.html\n: A simple HTML file that lists nearly 500 payday lenders licensed to do business in Illinois. Their addresses are split across multiple lines.\n\n\n\n\n\n\nAs with other exercises, finished versions are in the \ncompleted\n folder.", 
            "title": "Parsing text across lines"
        }, 
        {
            "location": "/pt4/", 
            "text": "Making a function\n\n\nThis is a pretty quick task -- the next time we have to deal with a list from the same agency, we shouldn't have to spend time rewriting our code from scratch or even go back to revise it to handle a new file. We have something that works, so let's turn it into a function we can call whenever we need to parse addresses for a list of financial licensees.\n\n\nThis exercise contains the following files:\n\n\npayday_parser.py\n: Our parser from \nfrom the previous exercise\n. We'll turn the existing work into a function and generalize it a bit to handle a file that's not specifically the list of licensed payday lenders.\n\n\nconsumer_installment.html\n: Another listing from the state of Illinois, but this time it encompasses more than 1,000 licensed consumer installment lenders.\n\n\ncall_function.py\n: A script we'll write to call the parser function from \npayday_parser.py\n and direct it toward our HTML file.\n\n\nFinished versions are in the \ncompleted\n folder.", 
            "title": "Making a function"
        }, 
        {
            "location": "/pt5/", 
            "text": "Geocoding addresses\n\n\nFor any kind of analysis that involves mapping, having coordinates is a must. En masse, though, they aren't always easy to come by.\n\n\nOpen-source geographic information systems like \nQGIS\n don't have built-in options to figure out a location's latitude and longitude; \nEsri\n charges for some of its online geocoding services, too.\n\n\nEnter \ngeopy\n, a Python library that's designed to interact with a slew of third-party geolocation APIs. As part of a larger script, we can read lines of address data from a CSV file, send each through one of these services and return the results.\n\n\nIn this example, we'll be using Google's geocoding service, which is good at properly interpreting an address string even when it's partially malformed or contains extraneous information. As a free service, however, it will only geocode 2,500 addresses in a 24-hour period.\n\n\nWe'll be using the CSV file we made by parsing payday lender addresses from 3_parse_addresses. Our goal at the end is to have a new CSV file with three additional fields of information:\n\n\n\n\nGoogle's match for the address\n\n\nLatitude in decimal degrees (Y coordinate)\n\n\nLongitude in decimal degrees (X coordinate)\n\n\n\n\nGoogle's free geocoder can only handle five requests per second, so we're going to use Python's time functions to slow our requests down and set up a control flow so that we're all only geocoding the first five addresses -- a condition that can be removed at your discretion if you're working through this task on your own later.\n\n\nThe files we'll be working with:\n\n\n\n\n\n\ngeocode.py\n: A script we'll write to pass addresses through Google's geocoding service. It will take the results along with our initial data fields and send them all to a new CSV file.\n\n\n\n\n\n\npayday_lenders.csv\n: Our completed CSV file from 3_parse_addresses.\n\n\n\n\n\n\nA finished version is in \ncompleted\n.", 
            "title": "Geocoding addresses"
        }, 
        {
            "location": "/pt6/", 
            "text": "APIs and databases\n\n\nScraping isn't the only method for retrieving data; sometimes data resources on the internet \u2014 even one maintained by government agencies \u2014 actually want to give it away in a usable format. Web application rogramming interfaces exist to make this happen. More often than not, you pass a query through an API's URL and get a response in \nJSON\n (JavaScript Object Notation) format, which is highly structured and can look a lot like a Python list or dictionary.\n\n\nWe're going to query a \nSocrata\n API maintained by the city of Chicago. This \nparticular data source\n is where crime incidents are reported by the Chicago Police Department; the lag time for reporting is about one week.\n\n\nOur initial goal is to grab the most recent week of crimes in the system, which means pinging the API to figure out the date of the last crime and then grabbing every reported crime on that day and the previous six. This will involve some work with \ndatetime\n and date math in Python. \n\n\nWe're also going to inspect the incoming stream of JSON from the API to make sure we can tell if any are missing fields. This becomes important because we are going to feed each crime event into an \nSQLite\n database.\n\n\nSQLite may not be as robust as some other database managers, but it's part of the standard library in later versions of Python 2.7 and creates lightweight database files that are easy to connect to and query.\n\n\nWe'll write some automated queries for crime trends, including which beats in Chicago had the most reported narcotics crimes during the week and what the violent crime rate was in different communities.\n\n\nThis particular task uses these files:\n\n\n\n\n\n\nAPI.py\n: The main script that fetches data from the crime API, puts it in a SQLite database and runs queries on the data.\n\n\n\n\n\n\ncrime.db\n: A SQLite database that only has a table with population data for Chicago's various community areas. We'll add to it from the crime API.\n\n\n\n\n\n\nfun_with_datetime.py\n: A more focused look at datetime objects and how they work in Python.\n\n\n\n\n\n\nfun_with_sqlite.py\n: The fundamentals of connecting to, modifying and querying a database with Python.\n\n\n\n\n\n\ncrime_backup.json.zip\n: Shoddy internet or a downed website won't ruin this exercise; this is compressed JSON that represents a week of Chicago crime.\n\n\n\n\n\n\nFinished versions are in the \ncompleted\n folder.", 
            "title": "APIs and databases"
        }, 
        {
            "location": "/pt7/", 
            "text": "Unlocking data from databases\n\n\nMost of the internet demands data in forms that play nicely with it \u2014 especially for visualization. JavaScript libraries that dynamically assemble charts, graphs and maps typically want something that looks a lot more like the JSON we got from the crime API over a CSV file or a database table. And that's OK, because it just gives Python another chance to shine.\n\n\nWe're going to write a few scripts that convert our crime data into \nGeoJSON\n, which is designed specifically to store geographic data like points, lines and polygons, as well as data that may be associated with those shapes.\n\n\nFrom there, we're going to layer them on a very basic \nLeaflet.js\n map that was hacked together from a few of their \ntutorials\n. \n\n\nInstead of having to load data into a GIS program like Esri's ArcGIS or the open-source QGIS and spend the time manually joining a table from a database to a shapefile and then exporting the whole affair to a web-friendly format, we'll handle it two ways.\n\n\nFirst, we'll write a section of script so that Python will generate GeoJSON straight from a database table. We'll use a new data type, \nOrderedDict\n, to store key/value pairs as well as the order in which they are added.\n\n\nThe next section of the Python script will process an existing GeoJSON polygon shapefile. It will check the ID of each polygon against an existing data set; if it finds a match, it will write new data into the shape.\n\n\nThe whole point here is that you can have Python acting as an autonomous data depot, pulling down new data from one side and sending it to update dynamic visualizations from the other.\n\n\nWe'll use the following files for this project:\n\n\n\n\n\n\nto_json.py\n: The script we'll write to make and alter GeoJSON files based on information in our existing crime.db.\n\n\n\n\n\n\nchicago_crime.html\n: An HTML file that contains JavaScript. It uses Leaflet.js to draw a map and other functions that are part of that library to incorporate GeoJSON files as map layers.\n\n\n\n\n\n\ncomm_areas.geojson\n: A GeoJSON file that contains all of Chicago's community areas. This originally existed as an Esri shapefile but was converted to this format in QGIS; there are also command line tools available that can do this, like \nogr2ogr\n.\n\n\n\n\n\n\nA finished version of the Python script is in \ncompleted\n.", 
            "title": "Unlocking data from databases"
        }, 
        {
            "location": "/pt8/", 
            "text": "Cleaning data\n\n\nNo data are ever perfect, but that doesn't mean you're not going to have to tangle with its shortcomings on deadline. Once we assess the issues, we can outsource the tedium of cleaning to a Python script. If we ever receive an updated data set from the same source, we have an automated way to run through out and output something we can use for reporting.\n\n\nThis exercise hits three different kinds of cleaning that are fairly common:\n\n\n\n\n\n\nData that don't arrive in flat file format, where one row equals one record. We'll work through a very formatted Excel file of candidate filings and convert it to a worksheet we can use.\n\n\n\n\n\n\nData that are just plain dirty: leading and trailing spaces, misspellings, unnecessary characters and more.\n\n\n\n\n\n\nParsing out names. We'll scrape some board and commission pages from the city of Chicago's website and use some hints in table to help us split names into title, first, middle, last and suffix.\n\n\n\n\n\n\nThe files:\n\n\n\n\n\n\nexcel.py\n: The script we'll write to turn formatted Excel designed for printing into a flat file we can use for analysis and reporting.\n\n\n\n\n\n\nfun_with_excel.py\n: A tour of the \nopenpyxl\n library and how it can read and write Microsoft Excel formats from 2007 and later.\n\n\n\n\n\n\nclean_csv.py\n: We'll write Python in this to process a dirty CSV file.\n\n\n\n\n\n\nnames.py\n: The script that will scrape board and commission pages and process the names.\n\n\n\n\n\n\nCandidates.xlsx\n: Our formatted Excel file of campaign filings.\n\n\n\n\n\n\nCandidates_backup.xlsx\n: A backup of the formatted Excel file (in case we mess it up). \n\n\n\n\n\n\nrahm_spending.csv\n: The problematic CSV file with dirty columns. \n\n\n\n\n\n\nIn case of no internet, \nboards_backup\n contains the files to scrape for \nnames.py\n. Finished versions are in \ncompleted\n.", 
            "title": "Cleaning data"
        }, 
        {
            "location": "/pt9/", 
            "text": "Other scrapes\n\n\nScraping can be about more than parsing tables tags in HTML.\n\n\nThe first thing we'll do is collect files from a website with Python.\n\n\nThen we'll turn out attention to this common problem: \njavascript:__doPostBack()\n isn't a link you can follow with a click in Python, but sometimes the data you need is behind it. \n\n\nIf we're trying to collect data from a government website using ASP.NET, we can watch the transaction between our browser and the site unfurl using developer tools like the ones built into Chrome. The requests library isn't just good for fetching URLs \u2014 it's full service. It can POST information as well with the intention of getting a response from the site. Based on what we see in terms of exhanged headers, we can copy that information and use requests to send it ourselves.\n\n\nThe files we'll be using:\n\n\n\n\n\n\nother_scrapes.py\n: This script will collect a set of PDFs. We'll point BeautifulSoup at the page contents to collect the links and then pipe the contents of those links (the PDFs) to files on our machine.\n\n\n\n\n\n\nother_scrapes_post.py\n: We'll use requests to POST data to the Illinois Elections site, causing its ASP.NET framework to give us a tab-delimited text file that contain's the days political contributions.", 
            "title": "Other scrapes"
        }, 
        {
            "location": "/pt10/", 
            "text": "Encoding and debugging\n\n\nIt's hard to succinctly describe why text encoding is a problem. Basically, it stems from the early days of computing when Western characters mattered. Others, not so much \u2014 they were barely an afterthought. \n\n\nBy the way, the em-dash on the last sentence? That can be represented many different ways based on the encoding of the text.\n\n\nDifferent encodings translate the bits that underpin all manner of characters into what we actually see on screen. Many have the same for A through Z, 0 through 9 and basic punctuation, so you don't even know you have a problem.\n\n\nFor more information, read this \nsweeping overview\n.\n\n\nWhen it's a problem, the trick is to decode your input early into \nunicode\n, do whatever you need to do with your code, and then encode back into something like UTF8 when it's been written to a file.\n\n\nWe encountered this a bit during our scrape at the beginning of the workshop. We had a few columns in the table with these other characters, and we were combining them with regular strings into individual lines that would be written to a CSV. We encoded them before they were written so they didn't break our script.\n\n\nFiles to use:\n\n\n\n\n\n\nencoding.py\n: A script where we're trying to read a text file, print the lines to the screen and then write the output to another text file. It's not working out so well.\n\n\n\n\n\n\nbroken_code.png\n: Flow chart for common errors in Python, what they mean and what else you can check when things aren't working out exactly as you expect them to.\n\n\n\n\n\n\nsome_text.txt\n: A simple text file, encoded in Windows-1252, known by \nPython as 'cp1252.'\n\n\n\n\n\n\nAs always, a working version of the script is in \ncompleted\n.", 
            "title": "Text encoding and debugging"
        }, 
        {
            "location": "/next_steps/", 
            "text": "Next Steps\n\n\nIf you're curious about the different paths for installing Python and various libraries on your own computer, some excellent resources exist as part of the \nPyCAR\n repository. The \ntake-home portion\n points to several tutorials and guides that cover Mac and PC setup, how to compartmentalize projects in their own virtual environments and the use of version control.\n\n\nIf you want to use a virtualenv, we've included a (short) requirements file for \npip\n with all the non-standard libraries used and their dependencies.\n\n\nHere are stops to make as you expand your knowledge and keep practicing these news skills:\n\n\n\n\nAgain, the \nPyCAR\n repository, a daylong class taught at the 2014 and 2015 NICAR Conferences.\n\n\nAnthony Debarros' \npython-get-started\n repository and his useful \npython-snippets\n, a list of practical code examples.\n\n\nBen Welsh's updated guide to building \na web scraper in Python\n and his guide for building \na lightweight news app\n.\n\n\nLearnPython\n is an interactive tutorial that covers a lot of this same ground and more.\n\n\n\n\nVersion control\n\n\nAs you start feeling more comfortable with the basics, you may want to start using a version control setup like \ngit\n to catalog your scripts, collaborate with others and share your code with the world.\n\n\nHere are a couple of guides from NICAR presenters and other sources that may come in handy:\n\n\n\n\nTom Meagher's \ntipsheet on git and GitHub\n\n\nResources and code shared during NICAR15\n from the fine folks at GitHub \n\n\nLauren Orsini's \nguide for beginners\n\n\nGitHub's own \ncommand cheat sheet", 
            "title": "Next steps"
        }
    ]
}